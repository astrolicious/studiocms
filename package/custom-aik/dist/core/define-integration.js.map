{"version":3,"sources":["../../src/core/define-integration.ts","../../src/internal/error-map.ts"],"sourcesContent":["import type { AstroIntegration } from \"astro\";\nimport { AstroError } from \"astro/errors\";\nimport { z } from \"astro/zod\";\nimport { errorMap } from \"../internal/error-map.js\";\nimport type {\n\tAnyPlugin,\n\tExtendedHooks,\n\tHookParameters,\n\tHooks,\n} from \"./types.js\";\n\n/**\n * A powerful wrapper around the standard Astro Integrations API. It allows to provide extra hooks, functionality\n * and best-practices when creating Astro Integrations.\n *\n * @param {object} params\n * @param {string} params.name - The name of your integration\n * @param {import(\"astro/zod\").AnyZodObject} params.optionsSchema - An optional zod schema to handle your integration options\n * @param {Array<AnyPlugin>} params.plugins - An optional array of plugins\n * @param {function} params.setup - This will be called from your `astro:config:setup` call with the user options\n *\n * @see https://astro-integration-kit.netlify.app/utilities/define-integration/\n *\n * @example\n * ```ts\n * export default defineIntegration({\n * \t\tname: \"my-integration\",\n * \t\tsetup({ options }) {\n * \t\t\tconsole.log(options.foo); // \"bar\"\n * \t\t}\n * })\n * ```\n */\nexport const defineIntegration = <\n\tTOptionsSchema extends z.ZodTypeAny = z.ZodNever,\n\tTPlugins extends Array<AnyPlugin> = [],\n>({\n\tname,\n\toptionsSchema,\n\tsetup,\n\tplugins: _plugins,\n}: {\n\tname: string;\n\toptionsSchema?: TOptionsSchema;\n\tplugins?: TPlugins;\n\tsetup: (params: {\n\t\tname: string;\n\t\toptions: z.output<TOptionsSchema>;\n\t}) => ExtendedHooks<TPlugins>;\n}): ((\n\t...args: [z.input<TOptionsSchema>] extends [never]\n\t\t? []\n\t\t: undefined extends z.input<TOptionsSchema>\n\t\t  ? [options?: z.input<TOptionsSchema>]\n\t\t  : [options: z.input<TOptionsSchema>]\n) => AstroIntegration) => {\n\treturn (...args) => {\n\t\tconst parsedOptions = (optionsSchema ?? z.never().optional()).safeParse(\n\t\t\targs[0],\n\t\t\t{\n\t\t\t\terrorMap,\n\t\t\t},\n\t\t);\n\n\t\tif (!parsedOptions.success) {\n\t\t\tthrow new AstroError(\n\t\t\t\t`Invalid options passed to \"${name}\" integration\\n`,\n\t\t\t\tparsedOptions.error.issues.map((i) => i.message).join(\"\\n\"),\n\t\t\t);\n\t\t}\n\n\t\tconst options = parsedOptions.data as z.output<TOptionsSchema>;\n\n\t\tconst resolvedPlugins = Object.values(\n\t\t\t(() => {\n\t\t\t\tconst plugins: Record<string, AnyPlugin> = {};\n\t\t\t\tfor (const plugin of _plugins ?? []) {\n\t\t\t\t\tplugins[plugin.name] = plugin;\n\t\t\t\t}\n\t\t\t\treturn plugins;\n\t\t\t})(),\n\t\t);\n\n\t\tconst providedHooks = setup({ name, options });\n\n\t\tconst definedHooks = Object.keys(providedHooks) as Array<keyof Hooks>;\n\n\t\tconst hooks: AstroIntegration[\"hooks\"] = Object.fromEntries(\n\t\t\tdefinedHooks.map((hookName) => [\n\t\t\t\thookName,\n\t\t\t\t// We know all hook parameters are objects, but the generic correlation makes TS ignore that fact.\n\t\t\t\t// The intersection with `object` is a workaround so TS doesn't complay about the spread below.\n\t\t\t\t(params: object & HookParameters<typeof hookName>) => {\n\t\t\t\t\tconst plugins = resolvedPlugins.filter((p) => p.hook === hookName);\n\n\t\t\t\t\treturn providedHooks[hookName]?.({\n\t\t\t\t\t\t...params,\n\t\t\t\t\t\t...Object.fromEntries(\n\t\t\t\t\t\t\tplugins.map((plugin) => [\n\t\t\t\t\t\t\t\tplugin.name,\n\t\t\t\t\t\t\t\tplugin.implementation(params, { name }),\n\t\t\t\t\t\t\t]),\n\t\t\t\t\t\t),\n\t\t\t\t\t} as any);\n\t\t\t\t},\n\t\t\t]),\n\t\t);\n\n\t\treturn {\n\t\t\tname,\n\t\t\thooks,\n\t\t};\n\t};\n};\n","import type { ZodErrorMap } from \"astro/zod\";\n\n// Source: https://github.com/withastro/astro/blob/d278e66ec6ded7a3ad441e6c3c5f9c265217936f/packages/astro/src/content/error-map.ts\n\ntype TypeOrLiteralErrByPathEntry = {\n\tcode: \"invalid_type\" | \"invalid_literal\";\n\treceived: unknown;\n\texpected: Array<unknown>;\n};\n\nexport const errorMap: ZodErrorMap = (baseError, ctx) => {\n\tconst baseErrorPath = flattenErrorPath(baseError.path);\n\tif (baseError.code === \"invalid_union\") {\n\t\t// Optimization: Combine type and literal errors for keys that are common across ALL union types\n\t\t// Ex. a union between `{ key: z.literal('tutorial') }` and `{ key: z.literal('blog') }` will\n\t\t// raise a single error when `key` does not match:\n\t\t// > Did not match union.\n\t\t// > key: Expected `'tutorial' | 'blog'`, received 'foo'\n\t\tconst typeOrLiteralErrByPath = new Map<\n\t\t\tstring,\n\t\t\tTypeOrLiteralErrByPathEntry\n\t\t>();\n\t\tfor (const unionError of baseError.unionErrors.flatMap((e) => e.errors)) {\n\t\t\tif (\n\t\t\t\tunionError.code === \"invalid_type\" ||\n\t\t\t\tunionError.code === \"invalid_literal\"\n\t\t\t) {\n\t\t\t\tconst flattenedErrorPath = flattenErrorPath(unionError.path);\n\t\t\t\tif (typeOrLiteralErrByPath.has(flattenedErrorPath)) {\n\t\t\t\t\ttypeOrLiteralErrByPath\n\t\t\t\t\t\t.get(flattenedErrorPath)!\n\t\t\t\t\t\t.expected.push(unionError.expected);\n\t\t\t\t} else {\n\t\t\t\t\ttypeOrLiteralErrByPath.set(flattenedErrorPath, {\n\t\t\t\t\t\tcode: unionError.code,\n\t\t\t\t\t\treceived: (unionError as any).received,\n\t\t\t\t\t\texpected: [unionError.expected],\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst messages: string[] = [\n\t\t\tprefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\ttypeOrLiteralErrByPath.size\n\t\t\t\t\t? \"Did not match union:\"\n\t\t\t\t\t: \"Did not match union.\",\n\t\t\t),\n\t\t];\n\t\treturn {\n\t\t\tmessage: messages\n\t\t\t\t.concat(\n\t\t\t\t\t[...typeOrLiteralErrByPath.entries()]\n\t\t\t\t\t\t// If type or literal error isn't common to ALL union types,\n\t\t\t\t\t\t// filter it out. Can lead to confusing noise.\n\t\t\t\t\t\t.filter(\n\t\t\t\t\t\t\t([, error]) =>\n\t\t\t\t\t\t\t\terror.expected.length === baseError.unionErrors.length,\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.map(([key, error]) =>\n\t\t\t\t\t\t\tkey === baseErrorPath\n\t\t\t\t\t\t\t\t? // Avoid printing the key again if it's a base error\n\t\t\t\t\t\t\t\t  `> ${getTypeOrLiteralMsg(error)}`\n\t\t\t\t\t\t\t\t: `> ${prefix(key, getTypeOrLiteralMsg(error))}`,\n\t\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.join(\"\\n\"),\n\t\t};\n\t}\n\tif (\n\t\tbaseError.code === \"invalid_literal\" ||\n\t\tbaseError.code === \"invalid_type\"\n\t) {\n\t\treturn {\n\t\t\tmessage: prefix(\n\t\t\t\tbaseErrorPath,\n\t\t\t\tgetTypeOrLiteralMsg({\n\t\t\t\t\tcode: baseError.code,\n\t\t\t\t\treceived: (baseError as any).received,\n\t\t\t\t\texpected: [baseError.expected],\n\t\t\t\t}),\n\t\t\t),\n\t\t};\n\t} else if (baseError.message) {\n\t\treturn { message: prefix(baseErrorPath, baseError.message) };\n\t} else {\n\t\treturn { message: prefix(baseErrorPath, ctx.defaultError) };\n\t}\n};\n\nconst getTypeOrLiteralMsg = (error: TypeOrLiteralErrByPathEntry): string => {\n\tif (error.received === \"undefined\") return \"Required\";\n\tconst expectedDeduped = new Set(error.expected);\n\tswitch (error.code) {\n\t\tcase \"invalid_type\":\n\t\t\treturn `Expected type \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t\tcase \"invalid_literal\":\n\t\t\treturn `Expected \\`${unionExpectedVals(\n\t\t\t\texpectedDeduped,\n\t\t\t)}\\`, received ${JSON.stringify(error.received)}`;\n\t}\n};\n\nconst prefix = (key: string, msg: string) =>\n\tkey.length ? `**${key}**: ${msg}` : msg;\n\nconst unionExpectedVals = (expectedVals: Set<unknown>) =>\n\t[...expectedVals]\n\t\t.map((expectedVal, idx) => {\n\t\t\tif (idx === 0) return JSON.stringify(expectedVal);\n\t\t\tconst sep = \" | \";\n\t\t\treturn `${sep}${JSON.stringify(expectedVal)}`;\n\t\t})\n\t\t.join(\"\");\n\nconst flattenErrorPath = (errorPath: (string | number)[]) =>\n\terrorPath.join(\".\");\n"],"mappings":"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","names":["AstroError","z","errorMap","baseError","ctx","baseErrorPath","flattenErrorPath","typeOrLiteralErrByPath","unionError","e","flattenedErrorPath","prefix","error","key","getTypeOrLiteralMsg","expectedDeduped","unionExpectedVals","msg","expectedVals","expectedVal","idx","errorPath","defineIntegration","name","optionsSchema","setup","_plugins","args","parsedOptions","z","errorMap","AstroError","i","options","resolvedPlugins","plugins","plugin","providedHooks","definedHooks","hooks","hookName","params","p"]}